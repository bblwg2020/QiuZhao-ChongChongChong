* 题目
#+DOWNLOADED: file:/var/folders/73/53s3wczx1l32608prn_fdgrm0000gn/T/TemporaryItems/（screencaptureui正在存储文稿，已完成7）/截屏2020-06-17 下午12.36.52.png @ 2020-06-17 12:36:54
[[file:Screen-Pictures/%E9%A2%98%E7%9B%AE/2020-06-17_12-36-54_%E6%88%AA%E5%B1%8F2020-06-17%20%E4%B8%8B%E5%8D%8812.36.52.png]]

* 思路
捋一捋
    题目说给定的输入是有效的，那么就意味着不会存在  不能使 A、B 数组严格递增的交换方法，即不存在下列的数组情况
    A = {4 3}
    B = {1 2}
    上述数组怎么交换都是不满足条件的，因此这种情况是不会出现的

    A = {0 2 7 8}
    B = {1 5 4 9}
             ↑
             i
    对于位置 i ，必定 满足以下两种情况 之一 或 同时满足：
    1、A[i] > A[i - 1] && B[i] > B[i - 1]
    2、A[i] > B[i - 1] && B[i] > A[i - 1]
    第一种情况很好理解
    第二种的话，就是如果至少存在 A、B 一边不是严格递增的，这表示需要进行交换，
    而能够交换的前提，就是交换后的值必定满足递增，即如果是 A[i] 和 B[i] 交换，那么 B[i] 必须大于 A[i - 1]，同理新的 A[i] > B[i - 1]，才能在交换后递增

    (上面我重新看了下，写得不是很清楚，下面列举情况就可以看清楚了)

    当只满足 A[i] > A[i - 1] && B[i] > B[i - 1]，那么我们可以有以下选择：
        1、i 交换，那么 i - 1 必须交换
        2、i 不交换，那么 i - 1 必须不交换
    当只满足 A[i] > B[i - 1] && B[i] > A[i - 1]，那么我们可以有以下选择：
        1、i 交换，那么 i - 1 必须不交换
        2、i 不交换，那么 i - 1 必须交换
    当同时满足两个条件，即 A[i] > A[i - 1] && B[i] > B[i - 1]，同时 A[i] > B[i - 1] && B[i] > A[i - 1]，那么我们可以有这么几种情况：
        1、 i 交换，那么 i - 1 可以选择交换或不交换，选择最优情况
        2、 i 不交换，那么 i - 1 同样可以选择 交换 或 不交换，选择最优情况

    我们需要对交换 i 和 交换 i - 1 进行判断哪种交换方式才是最优，
    那么我们就需要使用 一个 二维数组 或 两个 一维数组   ：  一个记录交换 i 的情况，一个记录交换 i - 1 的情况
* code
#+BEGIN_SRC python
class Solution:
    def minSwap(self, A: List[int], B: List[int]) -> int:
        swap, keep = [100 for i in range(len(A))], [100 for i in range(len(A))]
        swap[0], keep[0] = 1, 0
        for i in range(1, len(A)):
            if (A[i] > A[i-1] and B[i] > B[i-1]) and (A[i] > B[i-1] and B[i] > A[i-1]):
                # not change i
                keep[i] = min(keep[i-1], swap[i-1])
                # change i
                swap[i] = min(keep[i-1], swap[i-1]) + 1
            elif A[i] > A[i-1] and B[i] > B[i-1]:
                # not change i
                keep[i] = keep[i-1]
                # change i 
                swap[i] = swap[i-1] + 1
            else:
                # not change i
                keep[i] = swap[i-1]
                # change i
                swap[i] = keep[i-1] + 1
        # print(keep)
        # print(swap)
        return min(keep[len(A)-1], swap[len(A)-1])
#+END_SRC
