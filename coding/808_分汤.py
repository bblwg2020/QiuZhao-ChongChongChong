'''
题目描述：
有 A 和 B 两种类型的汤。一开始每种类型的汤有 N 毫升。有四种分配操作：

提供 100ml 的汤A 和 0ml 的汤B。
提供 75ml 的汤A 和 25ml 的汤B。
提供 50ml 的汤A 和 50ml 的汤B。
提供 25ml 的汤A 和 75ml 的汤B。
当我们把汤分配给某人之后，汤就没有了。每个回合，我们将从四种概率同为0.25的操作中进行分配选择。如果汤的剩余量不足以完成某次操作，我们将尽可能分配。当两种类型的汤都分配完时，停止操作。

注意不存在先分配100 ml汤B的操作。

需要返回的值： 汤A先分配完的概率 + 汤A和汤B同时分配完的概率 / 2。

示例:
输入: N = 50
输出: 0.625
解释:
如果我们选择前两个操作，A将首先变为空。对于第三个操作，A和B会同时变为空。对于第四个操作，B将首先变为空。
所以A变为空的总概率加上A和B同时变为空的概率的一半是 0.25 *(1 + 1 + 0.5 + 0)= 0.625。
注释:

0 <= N <= 10^9。
返回值在 10^-6 的范围将被认为是正确的。

解题思路：
DP (详细步骤见代码的注释)
关键几点：
1.每个dp元素的表示
2.N大于某个数字时，近似认为1（很难推导，有个印象就好 ）
3.取模减少运算（因为分配汤的量都能被25整除）




'''

class Solution:
    def soupServings(self, N: int) -> float:
        #先定义dp!!!!*难点
        #dp[i,j]表示当前A 剩余iml B剩余 j 毫升 时，所求的概率
        #dp[i,j]=1/4*(dp[i-100,j-0]+dp[i-75,j-25]+dp[i-50,j-50]+dp[i-25,j-75])
        #缩减25倍：
        #dp[i,j]=1/4*(dp[i-4,j-0]+dp[i-3,j-1]+dp[i-2,j-2]+dp[i-1,j-3])
        #边界条件：
        #dp[i,j] i<=0,j<=0 dp[i,j]==0.5
        #dp[i,j] i>0,j<=0 dp[i,j]==0
        #dp[i,j] i<=0,j>0 dp[i,j]==1


        #当N 大于500*25的时候概率接近1.
        if N>500*25:
            return 1
        #易错点：
        #减少计算量 (取模)
        N=N//25 if N%25==0 else N//25+1
        dp=[[0 for _ in range(N+1)] for _ in range(N+1)]
        def dp_num(i,j):
            if i<=0 and j<=0:return 0.5
            if i>0 and j<=0:return 0
            if i<=0 and j>0:return 1
            return dp[i][j]
        for  i in range(N+1):
            for j  in range(N+1):
                
                
                dp[i][j]=\
                1/4*(dp_num(i-4,j-0)+dp_num(i-3,j-1)+dp_num(i-2,j-2)+dp_num(i-1,j-3))
        return dp[-1][-1]


                



        
