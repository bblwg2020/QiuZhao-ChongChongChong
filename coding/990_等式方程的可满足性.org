* 题目
#+DOWNLOADED: file:/var/folders/73/53s3wczx1l32608prn_fdgrm0000gn/T/TemporaryItems/（screencaptureui正在存储文稿，已完成111）/截屏2020-06-12 下午2.04.05.png @ 2020-06-12 14:04:08
[[file:Screen-Pictures/%E9%A2%98%E7%9B%AE/2020-06-12_14-04-08_%E6%88%AA%E5%B1%8F2020-06-12%20%E4%B8%8B%E5%8D%882.04.05.png]]

* 思路
图的连通问题，利用并查集先对相等的元素合并，在对不等的元素查找是否非连通
* code
#+BEGIN_SRC python
class Union_set(object):
    def __init__(self, n):
        self.parent = list(range(n))

    def find(self, index):
        while index != self.parent[index]:
            # self.parent[index] = self.parent[self.parent[index]]
            index = self.parent[index]
        return index

    def union(self, index0, index1):
        root_0 = self.find(index0)
        root_1 = self.find(index1)
        self.parent[root_0] = root_1

    def is_connected(self, index0, index1):
        root_0 = self.find(index0)
        root_1 = self.find(index1)
        if root_0 == root_1:
            return True
        else:
            return False

class Solution:
    def equationsPossible(self, equations: List[str]) -> bool:
        union_set = Union_set(26)
        for equation in equations:
            if equation[1] == '=':
                index0 = ord(equation[0]) - ord('a')
                index1 = ord(equation[-1]) - ord('a')
                union_set.union(index0, index1)

        for equation in equations:
            if equation[1] == '!':
                index0 = ord(equation[0]) - ord('a')
                index1 = ord(equation[-1]) - ord('a')
                if union_set.is_connected(index0, index1):
                    return False
        return True
#+END_SRC
