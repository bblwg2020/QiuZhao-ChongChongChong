"""
给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。
返回滑动窗口中的最大值。

进阶：
你能在线性时间复杂度内解决此题吗？

示例:
输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3
输出: [3,3,5,5,6,7] 
解释: 

  滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
 

提示：
1 <= nums.length <= 10^5
-10^4 <= nums[i] <= 10^4
1 <= k <= nums.length

解题思路：
（1）常规做法：通过切片得到滑动窗口，通过max不断更新滑窗中的最大值；时间复杂度：O(n*k)
（2）利用双向队列维护一个单调递减队列，确保队列头部始终是窗口中的最大值；max必定出现在队列头部位置
因为数组中的每个元素只入队、出队一次，所以时间复杂度是：O(n)
双向队列解法的易错点：
（1）左边界恰好就是上一轮循环的滑动窗口的「最大值」，在这一轮“滑动窗口”右移，它必须被移出。
（2）因为要检测到左边界移除，左边界的索引很重要，知道索引也就知道了具体的值，因此“双端队列”里存的应该是数组的索引
"""
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:

        # badcase 提前判断
        if not nums or not k: return []
        n = len(nums)
        if n <= k: return [max(nums)]
        
        win = []
        res = []
        for i in range(n):
            
            # 如果滑动窗口非空，新进来的数比队列里已经存在的数还要大
            # 则说明已经存在数一定不会是滑动窗口的最大值（它们毫无出头之日）
            # 将它们弹出
            if i >= k and win[0] == i - k:
                win.pop(0)

            while win and nums[win[-1]] <= nums[i]:
                win.pop()
            win.append(i) # 窗口中存放索引

            if i >= k-1:
                res.append(nums[win[0]])
            print('win:', win)

        return res
