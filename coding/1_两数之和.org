* 两数之和
** 题目
 #+DOWNLOADED: file:/var/folders/73/53s3wczx1l32608prn_fdgrm0000gn/T/TemporaryItems/（screencaptureui正在存储文稿，已完成27）/截屏2020-07-06 下午12.02.34.png @ 2020-07-06 12:02:37
 [[file:Screen-Pictures/%E9%A2%98%E7%9B%AE/2020-07-06_12-02-37_%E6%88%AA%E5%B1%8F2020-07-06%20%E4%B8%8B%E5%8D%8812.02.34.png]]
** 思路
 + 暴力法：O(n**2)
 + 双指针：将nums和下标zip后排序，用头尾2个指针向中间遍历，直至找出和等于目标值的2个索引，时间复杂度为排序的O(nlogn)+遍历的O(n) = O(nlogn)，空间为O(n)保存额外的数组
** code
 #+BEGIN_SRC python
 # 暴力-5920 ms
 class Solution:
     def twoSum(self, nums: List[int], target: int) -> List[int]:
         for i in range(len(nums)):
             for j in range(i+1, len(nums)):
                 if nums[i] + nums[j] == target:
                     return [i, j]

 # 双指针优化-56ms
 class Solution:
     def twoSum(self, nums: List[int], target: int) -> List[int]:
         # 双指针
         nums_ = sorted(zip(range(len(nums)), nums), key= lambda x:x[1])
         left, right = 0, len(nums)-1
         while left < right:
             if nums_[left][1] + nums_[right][1] > target:
                 right -= 1
             elif nums_[left][1] + nums_[right][1] < target:
                 left += 1
             else:
                 return [nums_[left][0], nums_[right][0]]
 #+END_SRC
* 三数之和
** 题目
#+DOWNLOADED: file:/var/folders/73/53s3wczx1l32608prn_fdgrm0000gn/T/TemporaryItems/（screencaptureui正在存储文稿，已完成28）/截屏2020-07-06 下午5.38.18.png @ 2020-07-06 17:38:20
[[file:Screen-Pictures/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/2020-07-06_17-38-20_%E6%88%AA%E5%B1%8F2020-07-06%20%E4%B8%8B%E5%8D%885.38.18.png]]
** 思路
+ 暴力：O(n**3)
+ 双指针优化：类似于两数之和的解法，只不过这里a+b=-c；可以知道a,b,c中至少有一个是负数，可以利用这个特性对遍历进行优化。

首先对nums排序，遍历nums的元素为c，则为了不出现重复的元素，在c右边的元素中寻找剩下a和b，这里就用双指针法寻找a和b，需要注意的是，会存在相同的元素，因此需要用while跳过相同的元素，为了在跳过相同元素时不越界，left必须<right-1。在第一层循环中，需要保证c<=0，因为a<=b<=c，如果a>0则不可能存在和为0
** code
#+BEGIN_SRC python
# 双指针优化-O(n**2)
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        # 双指针
        ans = []
        nums.sort()
        for i, c in enumerate(nums):
            if c <= 0 and (i==0 or nums[i]!=nums[i-1]):
                left, right = i+1, len(nums)-1
                while left < right:
                    if nums[left] + nums[right] == -c:
                        ans.append([c, nums[left], nums[right]])
                        while nums[right]==nums[right-1] and left<right-1:
                            right -= 1
                        while nums[left]==nums[left+1] and left<right-1:
                            left += 1
                        right -= 1
                        left += 1
                    elif nums[left] + nums[right] > -c:
                        while nums[right]==nums[right-1] and left<right-1:
                            right -= 1
                        right -= 1
                    else:
                        while nums[left]==nums[left+1] and left<right-1:
                            left += 1
                        left += 1
        return ans
#+END_SRC
* 四数之和
** 题目
#+DOWNLOADED: file:/var/folders/73/53s3wczx1l32608prn_fdgrm0000gn/T/TemporaryItems/（screencaptureui正在存储文稿，已完成29）/截屏2020-07-06 下午5.54.36.png @ 2020-07-06 17:54:38
[[file:Screen-Pictures/%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/2020-07-06_17-54-38_%E6%88%AA%E5%B1%8F2020-07-06%20%E4%B8%8B%E5%8D%885.54.36.png]]
** 思路
[[https://leetcode-cn.com/problems/4sum/solution/gu-ding-tao-lu-jian-dan-qing-xi-pai-xu-shuang-zhi-/][如何剪枝]]

剪枝优化后，时间2256ms -> 136ms
** code
#+BEGIN_SRC python
class Solution:
    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:
        ans = []
        # special case
        if len(nums)<4: return ans
        # normal case
        nums.sort()
        for i in range(len(nums)-3):
            # 最小的4个数和大于目标值
            if sum(nums[:4]) > target:
                break
	    # 剪枝	
            if (i==0 or nums[i]!=nums[i-1]) and nums[i]+nums[-3]+nums[-2]+nums[-1]>=target:
                for j in range(i+1, len(nums)-2):
                    # 最小的4个数和大于目标值
                    if sum(nums[j:j+3]) + nums[i] > target:
                        break
		    # 添加剪枝条件	
                    if (j==i+1 or nums[j]!=nums[j-1]) and nums[i]+nums[j]+nums[-2]+nums[-1]>=target:
                        left, right = j+1, len(nums)-1
                        while left < right:
                            if nums[i]+nums[j]+nums[left]+nums[right]==target:
                                ans.append([nums[i], nums[j], nums[left], nums[right]])
                                while nums[right]==nums[right-1] and left<right-1:
                                    right -= 1
                                while nums[left]==nums[left+1] and left<right-1:
                                    left += 1
                                right -= 1
                                left += 1
                            elif nums[i]+nums[j]+nums[left]+nums[right]>target:
                                while nums[right]==nums[right-1] and left<right-1:
                                    right -= 1
                                right -= 1
                            else:
                                while nums[left]==nums[left+1] and left<right-1:
                                    left += 1
                                left += 1
        return ans
#+END_SRC

* 
